#define _CRT_SECURE_NO_WARNINGS 1
#include"complex.h"
//1.数据结构的研究内容
//数据类型 线性结构 树形结构  表 树 图
//数据结构是一门研究非数值计算的程序设计中操作对象以及他们之间的关系和操作的学科


//2.基本概念和术语
//1.2.1
//1)数据 能输入计算机并且能被计算机处理的各种符号的集合 包括数值类型的数据和非数值类型的数据
//  数据元素 是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理 也称元素，记录，结点或定点
//  数据项  构成数据元素不可分割的最小单位
//  数据对象 性质相同的数据元素的集合 是数据的一个子集
//  总 数据元素是数据的元素 数据对象是数据的一个子集 数据项是数据元素的子集
//  数据项构成数据元素 数据元素构成数据  数据对象由性质相同的数据元素构成
//1.2.2
//1)数据结构 数据元素不是孤立存在的 他们之间存在某种关系 数据元素相互之间的关系称为结构
//  是指相互之间存在一种或多种特定关系的数据元素集合
//  数据结构是带结构的数据元素的集合
//  数据对象加上数据元素之间的关系 就是数据结构
//2)数据结构包括以下三方面的内容
//  逻辑结构  存储结构是逻辑关系的映像与元素本身的映像 
//  物理结构(存储结构) 逻辑结构是数据结构的抽象 存储结构是数据结构的实现  两者中和起来建立了数据元素之间的结构关系
//  数据的运算和实现
//3)逻辑结构的划分方法 (1)线性结构 (2)非线性结构  /(1)集合结构 (2)线性结构 (3)树形结构 (4)图状结构或网状结构 （前驱和后继不同）
//4)四种基本的存储结构 (1)顺序存储结构 (2)链式存储结构 (3)索引存储结构 (4)散列存储结构
//1.2.3
//数据类型和抽象数据类型
//1)数据类型定义：数据类型 数据类型是一组性质相同的值的集合以及定义于这个值集合上一组操作的总称  数据类型=值的集合+值集合上的一组操作
//  c语言数据类型存在不够用的情况 如表示栈 队列 树 图等  不能直接用数据类型来表示
//2)抽象数据类型 Abstract Date Type 是指一个数学模型以及定义在此数学模型上的一组操作 （我的理解是人抽象出一种数据类型 然后再再计算机上实现 先画图纸后建房）
//  形式定义 D(数据对象) S(D上关系集) P(D上基本操作集)
//  ADT 抽象数据类型名{              
//
//	数据对象<>
//
//	数据关系<>
//
//	基本操作<>
//    (参数表) (初始条件)  (操作结果)
//
//  }ADT 抽象数据类型名
//例
//  ADT Circle{
//
//  数据对象：D={r,x,y| r,x,y 均为实数}
//
//  数据关系：S={<r,x,y>|r是半径，<x,y>是圆心坐标}
//
//  基本操作：
//
//  Circle(&C,r,x,y)
//  操作结果：构造一个圆
//
//  double Area(C)
//  操作条件：圆存在
//  操作结果：计算面积
//
//  }ADT Circle

//3.抽象数据类型的表示与实现
//抽象函数数据类型复数的实现

void menu()
{
	printf("*********************\n");
	printf("****1.Add  2.Sub*****\n");
	printf("****3.Mul  4.Div*****\n");
	printf("****   0.Exit   *****\n");
	printf("*********************\n");
}
void assign(complex* e1,complex* e2)
{
	printf("请输入第一个复数的实部和虚部：");
	scanf("%d%d",&e1->realpart, &e1->imaqpart);
	printf("请输入第二个复数的实部和虚部：");
	scanf("%d%d", &e2->realpart, &e2->imaqpart);
}
int main()
{
	int input;
	do
	{
		menu();
		complex e1 = { 0 };
		complex e2 = { 0 };
		printf("请输入选项：");
		scanf("%d", &input);
		switch(input)
		{
		case Add:
			assign(&e1, &e2);
			complex_add(&e1, &e2); // 复数加法
			break;
		case Sub:
			assign(&e1, &e2);
			complex_sub(&e1, &e2);// 复数减法
			break;
		case Mul:
			assign(&e1, &e2);
			complex_mul(&e1, &e2); //复数乘法
			break;
		case Div:
			assign(&e1, &e2); 
			complex_div(&e1, &e2); //复数除法
			break;
		case Exit:
			printf("退出\n");
			break;
		default:
			printf("错误\n");
		}
		if (input != 0 && (e2.imaqpart != 0 || e2.realpart != 0))
		{
			printf("运算后结果为%d + %di\n", e1.realpart, e1.imaqpart);
		}	
		system("pause");
		system("cls");
		
	} while (input);
	return 0;
}

//4.算法和算法分析 
//1)算法的定义 对特定问题求解方法步骤的一种描述，它是指令的有限序列。
//  算法是解决问题的一种方法或一个过程，程序是用某种语言对算法的具体实现
//  程序=数据结构+算法 数据结构通过算法实现操作 算法通过数据结构设计程序
//2)算法特性 有穷性 确定性 可行性 输入(可有可无) 输出(要有)
//3)算法设计要求 正确性 可读性 健壮性(鲁棒性) 高效性
//4)在算法保证正确性 然后 是健壮性 可读性后比较算法好坏主要考虑算法效率 通过算法效率来评判不同算法的优劣程度
//  算法效率主要以两个方面考虑 1.时间效率 2.空间效率
//  算法运行的时间  = E^ 每条语句的频度*该语句执行一次所用的时间
//  忽略每条语句执行的时间 算法的时间效率可用每条语句的频度总量来衡量
//  简单比较语句频率 按照 算法的渐进时间复杂度来说 只需比较他们的数量级
//  如一个算法的语句总频率为 2*n^3+3*n^2+n   n-> 0无穷0 时该算法 的渐进时间复杂度T(n) = O(n^3)  (O为数量级的符号)
//  算法语句频度总量数量级通过计算算法中基本语句重复执行次数来获得 重复执行次数最多的语句
//5)分析算法时间复杂度的基本方法
//  1 找出语句频度最大的那条语句作为基本语句
//  2 计算基本语句的频度得到问题规模n的某个函数 f(n) = (执行次数)  f(n)的含义是循环执行n次后基本语句执行的次数  f(n)是关于n的函数
//  3 取其数量级用符号"O" 来表示
//  算法的时间复杂度有时候和数据集内容相关 一般来计算的是最坏时间复杂度 或 平均时间复杂度
//  对于复杂的算法 可以将他们分成几个容易估算的部分 然后利用加法规则和乘法规则计算时间复杂度
//  加法规则 若对T(n) = T1(n) + T2(n) 则取最大的为时间复杂度
//  乘法规则 若对T(n) = T1(n) * T2(n) 则取他们的乘积为时间复杂度
//  对算法的时间效率的排序从小到大有  算法的时间复杂度最好在立方阶以下 
//  常数阶 对数阶 线性阶 线性对数阶 平方阶 立方阶 K次方阶 指数阶
//6)渐进空间复杂度 算法所需存储空间的度量 记作S(n) =O(f(n)) n为问题的规模（或大小） f(n) 表示的是关于算法占用空间大小
//  算法占用的空间可以描述为 1 本身占有的空间 输入输出指令 常数 变量 等 2 算法要使用的辅助空间
//  算法的空间复杂度有时主要看所使用的辅助空间的大小